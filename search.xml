<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[jdk的Fork/Join框架]]></title>
      <url>%2F2016%2F12%2F27%2Fjdk%E7%9A%84Fork-Join%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[jkd7提供了一个用于并行执行任务的框架，是把一个大任务分割成若干个小任务，将小任务的执行结果汇总起来，得到大任务的结果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ForkJoinTaskDemo &#123; public static void main(String[] args) throws Exception &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); CountTask task = new CountTask(1, 5); Future&lt;Integer&gt; result = forkJoinPool.submit(task); System.out.println("1-5相加结果：" + result.get()); CountTask task2 = new CountTask(1, 100); Future&lt;Integer&gt; result2 = forkJoinPool.submit(task2); System.out.println("1-100相加结果：" + result2.get()); System.out.println("thread main end!"); &#125;&#125;public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private static int selitSize = 2; private int start, end; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; // 如果任务不需要再拆分 就开始计算 boolean canCompute = (end - start) &lt;= selitSize; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 拆分成两个子任务 int middle = (start + end) / 2; CountTask firstTask = new CountTask(start, middle); CountTask secondTask = new CountTask(middle + 1, end); // 开始执行任务 firstTask.fork(); secondTask.fork(); // 获取第一个任务的执行结果，得不到结果，此线程不会往下面执行。 Integer firstResult = firstTask.join(); Integer secoundResult = secondTask.join(); // 合并两个儿子的执行结果 sum = firstResult + secoundResult; &#125; return sum; &#125;&#125; 执行结果： 1-5相加结果：15 1-100相加结果：5050 thread main end! ForkJoinTask与一般的任务的主要区别在于它需要实现compute方法，在这个方法，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果任务不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，当前子任务如果不需要再继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完成并得到其结果。 fork()：这个方法决定了ForkJoinTask的异步执行，凭借这个方法可以创建新的任务。join()：该方法负责在计算完成后返回结果，因此允许一个任务等待另一个任务执行完成。 Fork/Join的执行逻辑是这样：第一步分割任务。需要有一个fork来把大任务分割成子任务，分割后的任务可能很大，还需要继续分割，直到分割的子任务足够小；分割的任务都放在当前线程所维护的双端队列中，进入队列的头部。第二步执行任务并得到结果。执行任务时，几个启动线程从队列中获取任务并执行，子任务执行完的结果统一放在一个队列里，启动一个线程从队列里拿数据，合并这些数据。 通常情况下我们不需要直接继承ForkJionTask，只需要继承它的子类，重载protected void coumpute()方法。ForkJionTask提供了两个子类：RecursiveAction：用于没有返回结果的任务。RecursiveTask：用于有返回结果的任务。 使用Fork/Jion统计某盘符下的文件数量：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ForkJoinTaskDemo &#123; private static final String DIR = "D:/creditease"; public static void main(String[] args) throws Exception &#123; CountingTask task = new CountingTask(Paths.get(DIR)); Integer count = new ForkJoinPool().invoke(task); System.out.println(DIR + "下面总文件数量：" + count); &#125;&#125;public class CountingTask extends RecursiveTask&lt;Integer&gt;&#123; private Path dir; public CountingTask(Path dir) &#123; this.dir = dir; &#125; @Override protected Integer compute() &#123; int count = 0; // 文件数 List&lt;CountingTask&gt; subTasks = new ArrayList&lt;&gt;(); try &#123; // 读取目录dir的子路径。 DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(dir); for (Path subPath : ds) &#123; if (Files.isDirectory(subPath, LinkOption.NOFOLLOW_LINKS)) &#123; subTasks.add(new CountingTask(subPath)); &#125; else &#123; count++; &#125; &#125; if (!subTasks.isEmpty()) &#123; // 在当前的ForkJoinPool上高度所有的子任务 for (CountingTask subTask : invokeAll(subTasks)) &#123; count += subTask.join(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; return count; &#125;&#125; 对于树形结构的遍历处理非常适合。 简单总结下： 使用Fork/Jion模式，可以方便的实现并发任务的拆分，不需要处理各种相关事务，同步、通信之类的，仅仅关注如何划分和组合中间结果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[springMvc 响应返回406 Not Acceptable]]></title>
      <url>%2F2016%2F12%2F17%2FspringMvc-%E5%93%8D%E5%BA%94%E8%BF%94%E5%9B%9E406-Not-Acceptable%2F</url>
      <content type="text"><![CDATA[spirngMvc请求时，响应返回406 Not Acceptable问题的分析和解决。请求地址： http://sso.taotao.com/user/yuanleilei/1.html?r=0.950404558563605 web.xml中springmvc的配置 &lt;servlet&gt; &lt;servlet-name&gt;taotao-web&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/taotao-sso-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;taotao-web&lt;/servlet-name&gt; &lt;!-- 伪静态 伪静态有利于SEO（搜索引擎优化） --&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 请求凡是以*.html的结尾的都将被springmvc拦截，都认为是springmvc的合法请求，都会进入springmvc框架中进行处理。 后台日志中,请求已接受到，并由UserController.check方法处理，创建了事务PROPAGATION_REQUIRED,ISOLATION_DEFAULT，连接到数据库jdbc:mysql://127.0.0.1:3306/taotao，执行了查询SELECT UPDATED,ID,USERNAME,EMAIL,PHONE,CREATED,PASSWORD FROM tb_user WHERE USERNAME = ?，视图解析时发生异常Resolving exception from handler...... org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation 123452016-12-17 09:56:09,804 [http-bio-8083-exec-8] [org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver]-[DEBUG] Resolving exception from handler [public org.springframework.http.ResponseEntity&lt;java.lang.Boolean&gt; com.taotao.sso.controller.UserController.check(java.lang.String,java.lang.Integer)]: org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation2016-12-17 09:56:09,805 [http-bio-8083-exec-8] [org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver]-[DEBUG] Resolving exception from handler [public org.springframework.http.ResponseEntity&lt;java.lang.Boolean&gt; com.taotao.sso.controller.UserController.check(java.lang.String,java.lang.Integer)]: org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation2016-12-17 09:56:09,805 [http-bio-8083-exec-8] [org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver]-[DEBUG] Resolving exception from handler [public org.springframework.http.ResponseEntity&lt;java.lang.Boolean&gt; com.taotao.sso.controller.UserController.check(java.lang.String,java.lang.Integer)]: org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation2016-12-17 09:56:09,805 [http-bio-8083-exec-8] [org.springframework.web.servlet.DispatcherServlet]-[DEBUG] Null ModelAndView returned to DispatcherServlet with name &apos;taotao-web&apos;: assuming HandlerAdapter completed request handling2016-12-17 09:56:09,805 [http-bio-8083-exec-8] [org.springframework.web.servlet.DispatcherServlet]-[DEBUG] Successfully completed request 原因：响应时设置了@RequestBody，把对象转换成json返回时，缺少依赖的jar包。加入依赖包：jackson-core-asl-x.jar，jackson-mapper-asl-x.jar问题解决. ###但是。问题还是存在springmvc有个规定，html的请求不以json返回。 我们配置的web.xml中，是以html为映射的 现在有两种解决方法：1。把web.xml的映射方式改为别的，比如.do，所有依赖这个映射的url都要以*.do结尾2。加一个映射， &lt;servlet-mapping&gt; &lt;servlet-name&gt;taotao-web&lt;/servlet-name&gt; &lt;!-- 伪静态 伪静态有利于SEO（搜索引擎优化） --&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;taotao-web&lt;/servlet-name&gt; &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 以/service开头的请求和以*.html结尾的请求，都是指向taotao-web的sevlet的。那么我们的请求地址可以是 http://sso.taotao.com/service/user/yuanleilei/1?r=0.950404558563605 需要返回json的请求 加上/service/..去掉.html。访问页面加上.html。请求风格也保持了统一。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis分片式集群，整合spring]]></title>
      <url>%2F2016%2F11%2F15%2Fredis%E5%88%86%E7%89%87%E5%BC%8F%E9%9B%86%E7%BE%A4%EF%BC%8C%E6%95%B4%E5%90%88spring%2F</url>
      <content type="text"><![CDATA[redis3.0之前使用的集群方式为 分片式集群。分片集群采用key的哈希值，来决定数据存储在那一台服务器上。分片集群依赖服务器的数量来进行key的哈希值计算，无法动态增加或减少服务节点。 分片式集群测试123456789101112131415161718192021222324252627282930313233343536373839404142434445import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.JedisShardInfo;import redis.clients.jedis.ShardedJedis;import redis.clients.jedis.ShardedJedisPool;/** 集群式的连接池 */public class ShardedJedisPoolDemo &#123; public static void main(String[] args) &#123; // 构建连接池配置信息 JedisPoolConfig poolConfig = new JedisPoolConfig(); // 设置最大连接数 poolConfig.setMaxTotal(50); // 定义集群信息 List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;JedisShardInfo&gt;(); // 一个服务，多个节点。。 shards.add(new JedisShardInfo("127.0.0.1", 6379)); shards.add(new JedisShardInfo("192.168.0.20", 6379)); // 定义集群连接池 ShardedJedisPool shardedJedisPool = new ShardedJedisPool(poolConfig, shards); ShardedJedis shardedJedis = null; try &#123; // 从连接池中获取到jedis分片对象 shardedJedis = shardedJedisPool.getResource(); /* for (int i=1;i&lt;=20;i++) &#123; shardedJedis.set("key" + i, "vlaue" + i); &#125;*/ // 从redis中获取数据 String value = shardedJedis.get("key6"); System.out.println(value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != shardedJedis) &#123; // 关闭，检测连接是否有效，有效则放回到连接池中，无效则重置状态 shardedJedis.close(); &#125; &#125; // 关闭连接池 shardedJedisPool.close(); &#125;&#125; 存储的数据会以key计算哈希，存储到两台服务器上。获取的时候会以key计算哈希从两台服务器上取 整合spring与spring整合，就是构建分片式集群的上下分环境，创建出相应的数据对象，配置对象等，通过spring注入的方式来获取到即可。按照上面的代码逻辑，外围执行环境是ShardedJedisPool，ShardedJedisPool构建时需要有两个参数，配置信息 和 集群信息 JedisPoolConfig poolConfig = new JedisPoolConfig(); // 配置信息 List&lt;JedisShardInfo&gt; shards = new ArrayList&lt;JedisShardInfo&gt;(); // 集群信息 shards 中有多个JedisShardInfo ShardedJedisPool shardedJedisPool = new ShardedJedisPool(poolConfig, shards); applicationContext-redis.xml配置文件12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"&gt; &lt;!-- redis连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="$&#123;redis.maxTotal&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- redis 分片式集群 连接池 --&gt; &lt;bean class="redis.clients.jedis.ShardedJedisPool"&gt; &lt;constructor-arg index="0" ref="jedisPoolConfig" /&gt; &lt;constructor-arg index="1"&gt; &lt;list&gt; &lt;bean class="redis.clients.jedis.JedisShardInfo"&gt; &lt;constructor-arg index="0" value="$&#123;redis.node1.host&#125;" /&gt; &lt;constructor-arg index="1" value="$&#123;redis.node1.port&#125;" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; string类型的 set 和 get 操作12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class RedisService &#123; @Autowired private ShardedJedisPool jedisPool; /** * set 操作 * @param key * @param value * @return */ public String set(String key, String value) &#123; ShardedJedis shardedJedis = null; try &#123; shardedJedis = jedisPool.getResource(); return shardedJedis.set(key, value); &#125; finally &#123; if (shardedJedis != null) &#123; // 关闭，检测连接是否有效，有效则放回到连接池中，无效则重置状态 shardedJedis.close(); &#125; &#125; &#125; /** * get 操作 * @param key * @return */ public String get(String key) &#123; ShardedJedis shardedJedis = null; try &#123; shardedJedis = jedisPool.getResource(); return shardedJedis.get(key); &#125; finally &#123; if (shardedJedis != null) &#123; // 关闭，检测连接是否有效，有效则放回到连接池中，无效则重置状态 shardedJedis.close(); &#125; &#125; &#125;&#125; 模板性代码封装上的的代码，重复太多，模板性的代码提出来。定义接口Function12345678public interface Function&lt;T, E&gt; &#123; /** * T 返回 类型，不确定，E 入参 不确定 * @param e * @return */ public T calback(E e);&#125; RedisService中。模板性代码提到execute方法中，入参为Function类型对象，可以确定入参类型为ShardedJedis。123456789101112private &lt;T&gt; T execute(Function&lt;T, ShardedJedis&gt; fun)&#123; ShardedJedis shardedJedis = null; try &#123; shardedJedis = jedisPool.getResource(); return fun.calback(shardedJedis); &#125; finally &#123; if (shardedJedis != null) &#123; // 关闭，检测连接是否有效，有效则放回到连接池中，无效则重置状态 shardedJedis.close(); &#125; &#125;&#125; 进一步确定返回类型set方法中调用execute，直接返回，那么返回类型确定 为String。别外，用人话讲，是因为作用域的问题，set方法的入参 需要用final关键字修饰。官方话讲，为了防止在调用外部变量的时候，该变量引用被修改，导致出现无法预料的问题。123456789/** set 操作 */public String set(final String key,final String value) &#123; return this.execute(new Function&lt;String, ShardedJedis&gt;() &#123; @Override public String calback(ShardedJedis e) &#123; return e.set(key, value); &#125; &#125;);&#125; 内部类中引用外部类的局部变量，需要用final修饰，这是合乎逻辑的：内部类执行完，局部变量销毁，外部类回调的时候该变量已经不存在了。“防止该引用被修改”。 代码预览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899@Servicepublic class RedisService &#123; @Autowired private ShardedJedisPool jedisPool; /** * set 操作 * * @param key * @param value * @return */ public String set(final String key, final String value) &#123; return this.set(key, value, null); &#125; /** * set 操作 ，并设置 生存时间 * * @param key * @param value * @param seconds * @return */ public String set(final String key, final String value, final Integer seconds) &#123; return this.execute(new Function&lt;String, ShardedJedis&gt;() &#123; @Override public String calback(ShardedJedis e) &#123; String str = e.set(key, value); if (seconds != null) &#123; e.expire(key, seconds); &#125; return str; &#125; &#125;); &#125; /** * get 操作 * * @param key * @return */ public String get(final String key) &#123; return this.execute(new Function&lt;String, ShardedJedis&gt;() &#123; @Override public String calback(ShardedJedis e) &#123; return e.get(key); &#125; &#125;); &#125; /** * 删除 操作 * * @param key * @return */ public Long del(final String key) &#123; return this.execute(new Function&lt;Long, ShardedJedis&gt;() &#123; @Override public Long calback(ShardedJedis e) &#123; return e.del(key); &#125; &#125;); &#125; /** * 设置生存时间 * * @param key * @param seconds * 生存时间 * @return */ public Long expire(final String key, final int seconds) &#123; return this.execute(new Function&lt;Long, ShardedJedis&gt;() &#123; @Override public Long calback(ShardedJedis e) &#123; return e.expire(key, seconds); &#125; &#125;); &#125; private &lt;T&gt; T execute(Function&lt;T, ShardedJedis&gt; fun) &#123; ShardedJedis shardedJedis = null; try &#123; shardedJedis = jedisPool.getResource(); return fun.calback(shardedJedis); &#125; finally &#123; if (shardedJedis != null) &#123; // 关闭，检测连接是否有效，有效则放回到连接池中，无效则重置状态 shardedJedis.close(); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring data jpa 复杂条件查询]]></title>
      <url>%2F2016%2F10%2F29%2Fspring-data-jpa-%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[使用 spring data jpa 封装的任意条件查询，可使用Pageable定义分页和排序。 一般方式定义接口，继承JpaRepository和JpaSpecificationExecutor。dao支持可以继承JpaRepository，条件查询可以继承JpaSpecificationExecutor。 12@(spring data jpa)Repository("resultInfoReposintory")public interface ResultInfoReposintory extends JpaRepository&lt;ResultInfo,Long&gt;,JpaSpecificationExecutor&lt;ResultInfo&gt; JpaSpecificationExecutor接口其中的两个方法 12List&lt;T&gt; findAll(Specification&lt;T&gt; spec); // 条件查询，不分页Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable); // 条件查询，分页和排序 代码实例 1234567891011121314// 构建Pageable对象，用于分页和排序int page = 0; // 当前页int pageSize = 20; // 每页显示多少条// 排序条件，以创建时间，更新时间 降序List&lt;Order&gt; orders = new ArrayList&lt;Sort.Order&gt;();orders.add(new Order(Direction.DESC, "createTime")); //createTime是ResultInfo实体中的属性名orders.add(new Order(Direction.DESC, "modifyTime"));Pageable pageable = new PageRequest(page,pageSize,new Sort(orders));// 构建查询条件对象 specificationSpecification&lt;ResultInfo&gt; specification = this.getSpecification(accNo, beginDate, endDate);// 执行分页查询Page&lt;ResultInfo&gt; page = resultInfoRepository.findAll(specification, pageable); 构建查询条件的方法。使用CriteriaQuery得到查询条件 123456789101112131415161718192021222324// 构建查询条件// root.get("accNo")中的accNo和 root.get("transDate")中的transDate，都是实体类中的属性名private Specification&lt;ResultInfo&gt; getSpecification(final String accNo, final String beginDate, final String endDate)&#123; Specification&lt;ResultInfo&gt; specification = new Specification&lt;ResultInfo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;ResultInfo&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; // 存储 多个在查询条件 List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;(); list.add(cb.equal(root.get("accNo").as(String.class), accNo)); Date begin = DateUtil.str2Date(beginDate, DateUtil.FORMAT_YYYY_MM_DD); Date end = DateUtil.str2Date(beginDate, DateUtil.FORMAT_YYYY_MM_DD); if(begin != null &amp;&amp; end != null)&#123; // 交易日期 list.add(cb.between(root.get("transDate").as(Date.class), begin, end)); &#125; Predicate[] p = new Predicate[list.size()]; return query.where(list.toArray(p)).getRestriction(); &#125; &#125;; return specification;&#125; 也可以使用CriteriaBuilder得到查询条件。下面代码的cb即是CriteriaBuilder的实例对象 12Predicate[] p = new Predicate[list.size()];return cb.and(list.toArray(p)); 最后会得到一个Page&lt;T&gt;对象实例，保存数据和分页信息。Page&lt;ResultInfo&gt; page = resultInfoRepository.findAll(specification, pageable);Page接口中的方法 12345678int getNumber(); // 当前页，第一页是0long getTotalElements(); // 总记录数int getSize(); // 每页显示多少条int getTotalPages(); // 总页数boolean isLast(); // 是否是最后一页boolean isFirst(); // 是否是第一页int getNumberOfElements(); // 当前页的记录条数List&lt;T&gt; getContent(); // 当前页的记录集合 自行封装构建复杂的查询条件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @Description * @author leileiyuan * @date 2016年11月28日 上午10:11:26 */@Servicepublic class EnterpriseServiceImpl&#123; @Autowired private EnterpriseRepository enterpriseRepository; public Page&lt;Enterprise&gt; queryEnterpriseInfo(Enterprise enterprise) &#123; // 构建Pageable对象，用于分页和排序 int page = 0; // 当前页 int pageSize = 20; // 每页显示多少条 // 排序条件，以创建时间，更新时间 降序 List&lt;Order&gt; orders = new ArrayList&lt;Sort.Order&gt;(); orders.add(new Order(Direction.DESC, "createTime")); //createTime是Enterprise实体中的属性名 orders.add(new Order(Direction.DESC, "modifyTime")); Pageable pageable = new PageRequest(page,pageSize,new Sort(orders)); // 构建查询条件，我们已经把请求的查询条件放在入参 enterprise中， Criteria&lt;Enterprise&gt; spec = this.getSpecifications(enterprise); Page&lt;Enterprise&gt; data = enterpriseRepository.findAll(spec, pageable); return data; &#125; // 建构查询条件 private Criteria&lt;Enterprise&gt; getSpecifications(Enterprise enterprise) &#123; Criteria&lt;Enterprise&gt; criteria = new Criteria&lt;Enterprise&gt;(); // 默认条件 // 企业状态为“正常”和“已到期”并且 List&lt;String&gt; eStatus = new ArrayList&lt;String&gt;(); eStatus.add(EnterpriseStatusEnum.normal.getValue()); //eStatus.add(EnterpriseStatusEnum.overDue.getValue()); criteria.add(Restrictions.in("eStatus", eStatus)); // 企业状态 为 正常和已到期 // 审核状态为“风控审核通过”的 List&lt;String&gt; chkStatus = new ArrayList&lt;String&gt;(); chkStatus.add(OperationAuditStatusEnum.chkStatus4.getValue()); chkStatus.add(enterprise.getChkStatus()); // 审核状态 criteria.add(Restrictions.in("chkStatus", chkStatus)); criteria.add(Restrictions.like("eId", enterprise.getEId())); // 企业编号 criteria.add(Restrictions.like("eName", enterprise.getEName())); // 企业名称 // 入网开始时间 - 入网结束时间 Date joinDateBegin = enterprise.getJoinDateBegin(); Date joinDateEnd = enterprise.getJoinDateEnd(); if(joinDateBegin!=null &amp;&amp; joinDateEnd!=null)&#123; criteria.add(Restrictions.between("joinDate",joinDateBegin, joinDateEnd)); &#125; // 到期开始时间 - 到期结束时间 Date eDueDateBegin = enterprise.geteDueDateBegin(); Date eDueDateEnd = enterprise.geteDueDateEnd(); if(eDueDateBegin!=null &amp;&amp; eDueDateEnd!=null)&#123; criteria.add(Restrictions.between("eDueDate", eDueDateBegin,eDueDateEnd)); &#125; criteria.add(Restrictions.equal("eStatus", enterprise.getEStatus())); // 企业状态 return criteria; &#125; Criteria对象的封装。实现了Specification接口，重写public Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder)方法。用来存储所有的查询条件。下面的代码中的toPredicate用来构建查询条件。是Criterion接口中的toPredicate 1234List&lt;Predicate&gt; predicates = new ArrayList&lt;Predicate&gt;(); for(Criterion c : criterions)&#123; predicates.add(c.toPredicate(root, query,builder)); &#125; Criteria对象完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;import org.springframework.data.jpa.domain.Specification;/** * Description: 查询条件的容器 * Predicate 为拼接好的条件或条件组合 * * @author leileiyuan * Create Date: 2016年11月28日 上午10:50:05 * @param &lt;T&gt; */public class Criteria&lt;T&gt; implements Specification&lt;T&gt; &#123; private List&lt;Criterion&gt; criterions = new ArrayList&lt;Criterion&gt;(); @Override public Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder) &#123; if (!criterions.isEmpty()) &#123; List&lt;Predicate&gt; predicates = new ArrayList&lt;Predicate&gt;(); for(Criterion c : criterions)&#123; predicates.add(c.toPredicate(root, query,builder)); &#125; // 将所有条件用 and 联合起来 if (predicates.size() &gt; 0) &#123; return builder.and(predicates.toArray(new Predicate[predicates.size()])); &#125; &#125; // 返回一个没有联接条件的Predicate return builder.conjunction(); &#125; /** * Description: 增加简单的条件表达式 * * @param criterion * @author leileiyuan * Create Date: 2015年6月25日 下午2:43:13 */ public void add(Criterion criterion)&#123; if(criterion!=null)&#123; criterions.add(criterion); &#125; &#125; &#125; Criterion接口代码。定义条件表达式。toPredicate(...)方法，跟org.springframework.data.jpa.domain.Specification&lt;T&gt;接口的toPredicate方法一样。用来构建条件的。 12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;/** * Description: 条件表达式接口 * Criteria是一种类型安全和更面向对象的查询。 * * @author leileiyuan * Create Date: 2016年11月28日 上午10:51:07 */public interface Criterion &#123; public enum Operator &#123; EQ, // 等于 equal NE, // 不等于 notEqual GT, // 大于 greaterThan LT, // 小于 lessThan GTE, // 大于等于 greaterThanOrEqualTo LTE, // 小于等于 lessThanOrEqualTo BETWEEN, // 大于等于 并且 小于等于 between LIKE, // 模糊匹配 like OR, // 或者 or AND // 并且 and &#125; /** * Description: 代表一个条件或多个条件的组合 * * @param root * 代表Criteria查询的根对象，Criteria查询的查询根定义了实体类型，能为将来导航获得想要的结果 * @param query * CriteriaQuery 代表一个specific的顶层查询对象，包含查询的各个部分：如select 、from、where、group by、order by等 * @param builder * CriteriaBuilder 用来构造CriteriaQuery的构建对象 * @return Predicate 相当于条件或条件组合 * @author leileiyuan * Create Date: 2015年6月25日 上午11:02:31 */ public Predicate toPredicate(Root&lt;?&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder); &#125; Criterion接口的实现有两个，LogicalExpression和SimpleExpression。LogicalExpression用来构建逻辑表达式；SimpleExpression用来构建简单表达式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.ArrayList;import java.util.List;import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;/** * Description: 逻辑表达式 ,用于复杂条件的联接 包含 AND OR * 形如select * from tableName where (expression1) and (expression2) * and 用来连接expression1 和expression2 这里的and就是逻辑表达式 * * @author leileiyuan * Create Date: 2016年11月28日 上午11:35:09 */public class LogicalExpression implements Criterion &#123; private Criterion[] criterions; // 逻辑表达式包含的表达式 private Operator operator; // 运算符 @Override public Predicate toPredicate(Root&lt;?&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder) &#123; // 存放 查询时要过滤的条件 List&lt;Predicate&gt; predicates = new ArrayList&lt;Predicate&gt;(); for (Criterion criterion : criterions) &#123; predicates.add(criterion.toPredicate(root, query, builder)); &#125; switch (operator) &#123; case AND: return builder.and(predicates.toArray(new Predicate[predicates.size()])); case OR: return builder.or(predicates.toArray(new Predicate[predicates.size()])); default: return null; &#125; &#125; public LogicalExpression() &#123; &#125; public LogicalExpression(Criterion[] criterions, Operator operator) &#123; super(); this.criterions = criterions; this.operator = operator; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import javax.persistence.criteria.CriteriaBuilder;import javax.persistence.criteria.CriteriaQuery;import javax.persistence.criteria.Expression;import javax.persistence.criteria.Path;import javax.persistence.criteria.Predicate;import javax.persistence.criteria.Root;/** * Description: 简单表达式。包括 EQ NE GT LT GTE LTE BETWEEN LIKE * * @author leileiyuan * Create Date: 2016年11月28日 上午11:16:58 */public class SimpleExpression implements Criterion &#123; private String fieldName; // 属性名 private Object value; // 属性所对应的值 private Object value2; // 属性所对应的值 使用在between时，第二个比较的数据值 private Operator operator; // 运算符 @SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;) @Override public Predicate toPredicate(Root&lt;?&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder) &#123; // TODO Auto-generated method stub Path expression = root.get(fieldName); switch (operator) &#123; case EQ: return builder.equal(expression, value); case NE: return builder.notEqual(expression, value); case GT: return builder.greaterThan(expression, (Comparable) value); case LT: return builder.lessThan(expression, (Comparable) value); case GTE: return builder.greaterThanOrEqualTo(expression, (Comparable) value); case LTE: return builder.lessThanOrEqualTo(expression, (Comparable) value); case BETWEEN: return builder.between(expression, (Comparable) value, (Comparable) value2); case LIKE: return builder.like((Expression&lt;String&gt;) expression, "%" + value +"%"); default: return null; &#125; &#125; public SimpleExpression() &#123; &#125; public SimpleExpression(String fieldName, Object value, Operator operator) &#123; super(); this.fieldName = fieldName; this.value = value; this.operator = operator; &#125; public SimpleExpression(String fieldName, Object value, Object value2, Operator operator) &#123; super(); this.fieldName = fieldName; this.value = value; this.value2 = value2; this.operator = operator; &#125; public String getFieldName() &#123; return fieldName; &#125; public void setFieldName(String fieldName) &#123; this.fieldName = fieldName; &#125; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value = value; &#125; public Object getValue2() &#123; return value2; &#125; public void setValue2(Object value2) &#123; this.value2 = value2; &#125; public Operator getOperator() &#123; return operator; &#125; public void setOperator(Operator operator) &#123; this.operator = operator; &#125; &#125; 逻辑表达式和简单表达式的条件构建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183import java.util.Collection;import org.springframework.util.StringUtils;/** * Description: 条件构造器 * * @author leileiyuan * Create Date: 2016年11月28日 下午1:55:57 */public class Restrictions &#123; /** * Description: 等于 * * @param fieldName 属性名 * @param value 属性名对应的值 * @return * value为null返回null; * value如果是java.lang.String类型的实例 转换成String值为""，也返回null * @author leileiyuan * Create Date: 2016年11月28日 下午1:59:35 */ public static SimpleExpression equal(String fieldName, Object value) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, Operator.EQ); &#125; /** * Description: 不等于 * * @param fieldName * @param value * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:04:17 */ public static SimpleExpression notEqual(String fieldName, Object value) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, Operator.NE); &#125; /** * Description: 大于 * * @param fieldName * @param value * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:04:44 */ public static SimpleExpression greaterThan(String fieldName, Object value) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, Operator.GT); &#125; /** * Description: 小于 * * @param fieldName * @param value * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:05:35 */ public static SimpleExpression lessThan(String fieldName, Object value) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, Operator.LT); &#125; /** * Description: 大于等于 * * @param fieldName * @param value * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:07:22 */ public static SimpleExpression greaterThanOrEqualTo(String fieldName, Object value) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, Operator.GTE); &#125; /** * Description: 小于等于 * * @param fieldName * @param value * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:07:57 */ public static SimpleExpression lessThanOrEqualTo(String fieldName, Object value) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, Operator.LTE); &#125; /** * Description: 大于等于 并且 小于等于 * * @param fieldName * @param value * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:08:43 */ public static SimpleExpression between(String fieldName, Object value, Object value2) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, value2, Operator.BETWEEN); &#125; /** * Description: 模糊匹配 * * @param fieldName * @param value * @param value2 * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:10:04 */ public static SimpleExpression like(String fieldName, Object value) &#123; if (StringUtils.isEmpty(value)) &#123; return null; &#125; return new SimpleExpression(fieldName, value, Operator.LIKE); &#125; /** * Description: 并且 * * @param criterions * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:12:31 */ public static LogicalExpression and(Criterion...criterions)&#123; return new LogicalExpression(criterions, Operator.AND); &#125; /** * Description: 或者 * * @param criterions * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:13:06 */ public static LogicalExpression or(Criterion...criterions)&#123; return new LogicalExpression(criterions, Operator.OR); &#125; /** * Description: 包含于 * * @param fieldName * @param values * @return * @author leileiyuan * Create Date: 2016年11月28日 下午2:21:58 */ @SuppressWarnings("rawtypes") public static LogicalExpression in(String fieldName, Collection values)&#123; SimpleExpression[] ses = new SimpleExpression[values.size()]; int i = 0; for (Object value : values) &#123; ses[i] = new SimpleExpression(fieldName, value, Operator.EQ); i++; &#125; return new LogicalExpression(ses, Operator.OR); &#125;&#125; 到此封装就基本完成了。 spring data jpa还提供了更复杂的多表联接查询1234567891011121314151617public class Qfjbxxdz &#123; @Id @GeneratedValue(generator = "system-uuid") @GenericGenerator(name = "system-uuid", strategy = "uuid.hex") private String id; @OneToOne @JoinColumn(name = "qfjbxx") private Qfjbxx qfjbxx; //关联表 private String fzcc; private String fzccName; @ManyToOne @JoinColumn(name = "criminalInfo") private CriminalInfo criminalInfo;//关联表 @Column(length=800) private String bz; //get/set......&#125; 可以用类似的方法来调用。qfjbxx，criminalInfo是关联表的属性对象，id,xm分别是Qfjbxx和CriminalInfo实体类的属性 12Predicate p1 = cb.equal(root.join("qfjbxx").get("id").as(String.class), id);Predicate p2 = cb.like(root.join("criminalInfo").get("xm").as(String.class), "%"+xm+"%"); CriteriaQuery对象也支持分组和排序 12345// 设置groupBy的条件query.groupBy( root.get("qid").as(String.class), root.get("fid").as(String.class)); 12// 设置orderBy的条query.orderBy(cb.asc(root.get("xm").as(String.class)));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用git访问远程gitub仓库]]></title>
      <url>%2F2016%2F10%2F22%2F%E4%BD%BF%E7%94%A8git%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8Bgitub%E4%BB%93%E5%BA%93%2F</url>
      <content type="text"><![CDATA[在windows下安装msysgit，使用git命令操作仓库，并推送到远程github仓库。安装过以后，打开 Git Bash,会显示类型以下信息 leileiyuan@08-201508200156 MINGW64 ~ $ 输入git --version命令，显示版本号。 $ git --version git version 2.9.3.windows.2 本地建立工作环境，提交到远程仓库中。最简步骤： makdir blog -- 创建一个项目blog $ cd blog -- 打开这个项目 $ git init -- 初始化 $ touch README.md $ git add README.md -- 更新README文件 $ git commit -m &apos;first commit&apos; -- 提交更新，并注释信息“first commit” $ git remote add origin https://github.com/leileiyuan/hexoSource.git -- 连接远程github项目 $ git push -u origin master -- 将本地项目推动到远程仓库 目录文件比较多时，可以一次性add多个文件及目录 git add --all 或者 git add -A 从远程仓库中下载工程环境 git clone https://github.com/leileiyuan/hexoSource.git blog git add . git commit -m &quot;master commit&quot; git push origin clone下来的分支是master，在本地建立分支dev，切换到远程分支dev上(origin/dev) git checkout -b dev origin/dev 更新本地工程,合并工程 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git pull origin master:master 合并分支，将远程master合并到本地dev分支 git pull origin master:dev 将远程分支与当前分支合并 git pull origin dev 相当于git fetch 和 git merge先抓取远程数据，对比下有什么不同之处，再合并。这样操作相对安全一些。 合并分支把branchName合并到当前分支 git merge branchName 合并时，可能会有冲突。手动把有冲突的文件编辑以后，添加索引，再commit有冲突(conflicts)的文件会保存在索引中，除非你解决了问题了并且更新了索引，否则执行 git commit都会失败 创建分支 git branch branchName 切换分支 git checkout brancnName 创建并切换到分支 git checkout -b branchName 查看分支列表 git branch 不带参数：列出所有分支 gir branch -r 列出远程分支 gir branch -a 列出本地和远程分支 提交到远程仓库 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; git push origin dev 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 $ git push origin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo构建个人博客]]></title>
      <url>%2F2016%2F08%2F09%2F%E4%BD%BF%E7%94%A8hexo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[hexo是一个快速、简单的博客框架。可能通过Markdown语言编写文章。hexo来帮助你生成各种主题风格的静态网站，支持多终端访问 安装hexo之前需要先安装node和git。 安装hexo执行下面的命令安装hexo $ npm install -g hexo 查看是否安装成功 $ hexo -v 可能显示这些信息，说明hexo安装成功 hexo: 3.2.2 hexo-cli: 1.0.2 os: Windows_NT 6.1.7601 win32 x64 http_parser: 2.7.0 node: 6.2.0 v8: 5.0.71.47 uv: 1.9.1 zlib: 1.2.8 ares: 1.10.1-DEV icu: 57.1 modules: 48 openssl: 1.0.2h Hexo的使用初始化站点$ hexo init blog blog是你的站点目录。hexo会在blog下构建必要的目录结构，创建必要的配置文件等初始化好的目录结构： . ├── _config.yml ├── package.json ├── scaffolds/ ├── scripts/ ├── source/ | ├── _drafts | └── _posts └── themes/ 各目录结构说明 _config.yml：站点的全局配置文件。package.json：应用数据。从它可以看出Hexo的版本信息，依赖的组件。scaffolds/：模板文件目录。创建新文章的时候，通过模板生成scripts/：js脚本文件目录。source/：文章目录。整个站点的数据内容，图片等。_drafts：在source/目录下的子目录，草稿放在这里。_posts：在source/目录下的子目录，文章放在这里。themes/：主题目录。hexo默认主题是landscape，难看。通常会下载一些别的主题放在这个目录下来使用，主题一般也有自己的配置文件。 创建文章$ hexo new &quot;测试文章&quot; INFO Created: D:\blog\source\_posts\测试文章.md 在source/_posts目录下生成一篇文章 编辑文章用文本编辑器打开”测试文章.md”文件，文章内容如下： --- title: 测试文章 date: 2016-11-26 11:48:41 tags: --- 在文章结尾，输入一些内容： ### 这是一篇测试文章 hexo的基本使用。。。。。。 构建网站$ hexo generate 构建网站会在blog站点目录下，生成一个目录public，用来存放生成的所有站点文件 启动服务，预览博客$ hexo s INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 如果电脑上安装了Foxit Reader褔昕阅读器，端口可能被占用，需要手动指定端口 $ hexo s -p 5000 INFO Start processing INFO Hexo is running at http://localhost:5000/. Press Ctrl+C to stop. Ctrl+C停止服务 浏览器中访问 http://localhost:5000/ 即可看到生成的主页。 清理$ hexo clean INFO Deleted database. INFO Deleted public folder. 主要是把public目录删除掉了。 一般在使用hexo generate命令构建博客的时候，会先清理下。 Hexo 主题hexo有一套默认的主题，不过太难看了。一般会安装一套别的主题使用 安装next主题我用一套主题是Next,命令安装： $ git clone https://github.com/iissnan/hexo-theme-next themes/next 安装成功后，会在themes目录里多出一个目录next就是该主题的文件 启用主题打开blog/_config.yml站点全局配置文件，设置 theme: next 清理 构建博客 启动服务 浏览器中预览效果。 hexo clean hexo g hexo s -p 5000 部署如果自己的域名或空间，可以把博客直接部署上去 我是部署到github上，在站点全局配置文件中配置： deploy: type: git repository: https://github.com/leileiyuan/leileiyuan.github.io.git branch: master 执行部署命令 hexo deploy 可以将生成的部署命令组合使用 hexo d -g 或 hexo g -d，是指生成后立刻部署。 使用到的命令列表： $ hexo init -- 初始化网站 $ hexo new &quot;新文章名&quot; -- 创建新文章 $ hexo new page tags -- 创建标签，创始分类，创建其它结构的目录，都可以用 $ hexo clean -- 清理 $ hexo g -- generate 构建 $ hexo s -- server 启动本地服务 $ hexo d -- deploy 部署到远程服务器 $ hexo s -p 5000 -- 指定启动本地服务的端口 $ hexo g -d -- 生成后部署 参考 Hexo中文官网： https://hexo.io/zh-cn/ Next主题官网： http://theme-next.iissnan.com/]]></content>
    </entry>

    
  
  
</search>
